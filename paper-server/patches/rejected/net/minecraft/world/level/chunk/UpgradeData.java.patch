From 3aeeaf31b7a7f888f54e47826e8ec0ddbe65c4bf Mon Sep 17 00:00:00 2001
From: File <noreply+automated@papermc.io>
Date: Sun, 20 Apr 1997 14:37:42 +0100
Subject: [PATCH] paper File Patches


diff --git a/net/minecraft/world/level/chunk/UpgradeData.java b/net/minecraft/world/level/chunk/UpgradeData.java
index 77282a6cd9e5008cf8fc9a0d3e940e7abaaa8a0a..aa1aace33ca249c19ff20cf1b908571c63b5b6bc 100644
--- a/net/minecraft/world/level/chunk/UpgradeData.java
+++ b/net/minecraft/world/level/chunk/UpgradeData.java
@@ -113,6 +113,24 @@ public class UpgradeData {
         }
     }
 
+    // Paper start - filter out relocated neighbour ticks
+    // The lists are only supposed to contain ticks for the 1 radius neighbours of the chunk
+    private static <T> void filterTickList(int chunkX, int chunkZ, List<SavedTick<T>> ticks) {
+        for (java.util.Iterator<SavedTick<T>> iterator = ticks.iterator(); iterator.hasNext();) {
+            SavedTick<T> tick = iterator.next();
+            BlockPos tickPos = tick.pos();
+            int tickCX = tickPos.getX() >> 4;
+            int tickCZ = tickPos.getZ() >> 4;
+
+            int dist = Math.max(Math.abs(chunkX - tickCX), Math.abs(chunkZ - tickCZ));
+
+            if (dist != 1) {
+                LOGGER.warn("Neighbour tick '" + tick + "' serialized in chunk (" + chunkX + "," + chunkZ + ") is too far (" + tickCX + "," + tickCZ + ")");
+                iterator.remove();
+            }
+        }
+    }
+    // Paper end - filter out relocated neighbour ticks
     public void upgrade(LevelChunk chunk) {
         this.upgradeInside(chunk);
 
@@ -120,6 +138,10 @@ public class UpgradeData {
             upgradeSides(chunk, direction8);
         }
 
+        // Paper start - filter out relocated neighbour ticks
+        filterTickList(chunk.locX, chunk.locZ, this.neighborBlockTicks);
+        filterTickList(chunk.locX, chunk.locZ, this.neighborFluidTicks);
+        // Paper end - filter out relocated neighbour ticks
         Level level = chunk.getLevel();
         this.neighborBlockTicks.forEach(blockTicker -> {
             Block block = blockTicker.type() == Blocks.AIR ? level.getBlockState(blockTicker.pos()).getBlock() : blockTicker.type();
@@ -129,6 +151,7 @@ public class UpgradeData {
             Fluid fluid = fluidTicker.type() == Fluids.EMPTY ? level.getFluidState(fluidTicker.pos()).getType() : fluidTicker.type();
             level.scheduleTick(fluidTicker.pos(), fluid, fluidTicker.delay(), fluidTicker.priority());
         });
+        UpgradeData.BlockFixers.values(); // Paper - force the class init so that we don't access CHUNKY_FIXERS before all BlockFixers are initialised
         CHUNKY_FIXERS.forEach(fixers -> fixers.processChunk(level));
     }
 
